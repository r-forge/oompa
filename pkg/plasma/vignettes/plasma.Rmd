---
title: "plasma: Partial LeAst Squares for Multi-omics Analysis"
author: "Kevin R. Coombes"
data: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{plasma: Partial LeAst Squares for Multi-omics Analysis}
  %\VignetteKeywords{OOMPA,plasma,supervised analysis,partial least squares}
  %\VignetteDepends{plasma}
  %\VignettePackage{plasma}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r opts, echo=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=5)
options(width=96)
```
# Introduction

# Methods

# Results
We start by loading the package.
```{r pkgs}
suppressWarnings( library(plasma) )
```
Next, we load sample data derived from the esophageal cancer (ESCA) cohort of
The Cancer Genome Atlas (TCGA).
```{r data}
data("TCGA-ESCA")
ls()
```
The data we have available consist of

* `assemble`, a list of datasets;
* `m450info`, a data frame of annotation information about the probes from the
  Illumina 450K methylation array; and
* `Outcome`, a data frame of clinical outcomes, whihc basically comes down
  to overall survival.

Here is a summary of the outome data.
```{r outcome}
dim(Outcome)
summary(Outcome)
```

Here are the sizes of the data sets.
```{r sizes}
t(sapply(assemble, dim))
```
To be consistent with the `MOFA2` R package, all of the data sets are arranged so that
patient samples are columns and assay features are rows.

We should also point out that we have not included all of the available data for the ESCA
cohort. When getting the data ready to illustrate the `plasma` algorithm, we randomly removed
different fractions of the samples from the miRSeq, mRNASeq, and RPPA data sets. The point of
leaving them out is to be able to show that `plasma` can find useful components from any of
the included data sets and manage to extend them to the full cohort. In addition, the RPPA,
miRSeq, and mRNASeq data sets were filtered to keep features with larger means and standard
deviations, and the Meth450 data were filtered to keep only the most variable features.

## Preparing the Data
Our first task is to pad each data set with appropriate `NA`'s to ensure that each set
includes the same patient samples in the same order, where that order matches the outcome
data frame.

```{r prep}
MO <- prepareMultiOmics(assemble, Outcome)
#MO <- MO[c("ClinicalBin", "ClinicalCont", "RPPA", "MAF"),]
class(MO)
summary(MO)
```

We see that the number of patients in each data set is now equal to the number of patients
with clinical outcome data.

```{r fig01, fig.cap = "Overview of the ESCA data sets.", fig.width=5, fig.height=8}
opar <- par(mai = c(1.02, 1.32, 0.82, 0.22))
plot(MO, main = "All ESCA")
par(opar)
```

## Split Into Training and Test

```{r split}
set.seed(44931)
splitVec <- rbinom(nrow(Outcome), 1, 0.6)
table(splitVec)
```

```{r fig02, fig.cap = "Overview of training data.", fig.width=5, fig.height=8}
trainD <- MO[, splitVec == 1]
summary(trainD)
opar <- par(mai = c(1.02, 1.32, 0.82, 0.22))
plot(trainD, main = "Train")
par(opar)
```

```{r fig03, fig.cap = "Overview of test data.", fig.width=5, fig.height=8}
testD <- MO[, splitVec == 0]
summary(testD)
opar <- par(mai = c(1.02, 1.32, 0.82, 0.22))
plot(testD, main = "Test")
par(opar)
```

## PLS Cox Regression Models
Partial Least Squares (PLS) has been shown to be an effective method for finding components
that can predict clinically interesting outcomes {REFERENCE} . The first step of the `plasma`
algorithm is to fit PLS Cox models on each data set with the function `fitCoxModels`. The returned object of class `MultiplePLSCoxModels` contains a list of `SingleModel` objects, one for each assay, and within this are 4 different regression models:

* 1 plsRcoxmodel
* 3 separate models are made on the prediction of Risk made from using the training data on the above plsRcoxmodel
    + riskModel is a `coxph` model with predicted Risk as the predictors (continuous)
    + splitModel is a `coxph` model with Split as the predictors (Risk categorized into high and low by the median)
    + SF is a `survfit` model, which creates Kaplan-Meier curves corresponding to `splitModel`

```{r fig04, fig.width = 8, fig.height = 12}
suppressWarnings( firstPass <- fitCoxModels(trainD, timevar = "Days",
                          eventvar = "vital_status", eventvalue = "dead") )
summary(firstPass)
plot(firstPass)
```

## Extend the model components
The "extension" portion is done with the function plasma() where it takes in the previous created objects of class `multiOmics` and `MultiplePLSCoxModels` and returns an object of class `plasma`. Within the plasma() function, the PLS components from one dataset (ex. dataset A) is used to predict the PLS components from another dataset (ex. dataset B). The process does this iteratively such that in our case there are 7 different sets of predictions of the PLS components, which are averaged and saved to the object of class `plasma` as a dataframe called `meanPredictions`.

Similarly to the objects that are part of the `MultiplePLSCoxModels` object, there are `riskModel`, `splitModel`, and `SF` stored in the `plasma` object.

```{r plasma}
pl <- plasma(MO, firstPass)
plot(pl, legloc = "topright", main = "Training Data")
heatmap(pl@meanPredictions) # make a standard method?
summary(pl) # neds to be defined.
```

## Independent Test Set
Now we want to see how well any of the models we have constructed generalize to our test set.
```{r firstpre}
SM <- firstPass@models[[1]]
ND <- as.data.frame(t(testD@data[[1]]))
class(SM)
foo <- predict(SM, type = "risk")
foo <- predict(SM, type = "risk")
poo <- predict(SM, newdata = testD)
```

```{r testingFinal}
testpred <- predict(pl, testD)
plot(testpred, main="Testing", xlab = "Time (Days)")
```

## Interpretation

The weight matrix of the `plasma` object can be extracted using the `getAllWeights` and specifying the name of the dataset. This weight matrix has the features from the particular dataset specified as rows and all of the PLS components as columns. Setting a cutoff of significance for the `pickSignificant` function will return a different weight matrix in which the rows have been selected if they contributed significantly to defining the PLS components. PLS regression is a supervised method that aims to find linear combinations of predictor variables (i.e. components) that maximize the variance in both the predictors and the response (reference: An Introduction to Statistical Learning with Applications in R, 2nd Ed.). Therefore, these weight matrices can be analyzed even further by looking at their heatmaps, to examine the relative 1) direction and 2) magnitude with which the original variables in the omics datasets contributed to the final PLS components.

### Clinical Binary Data

```{r }
cbin <- getAllWeights(pl, "ClinicalBin")
image(cbin)
heat(cbin, cexCol = 0.5)
cbin01 <- pickSignificant(cbin, 0.01)
image(cbin01)
heat(cbin01, cexCol = 0.5)
getTop(cbin01, 3)
```


```{r}
# kyoko added this to see if she could get the heatmap to display all of the row and column labels?
heat(cbin01, cexCol=0.5)
```


### Clinical Continuous Data
```{r }
ccont <- getAllWeights(pl, "ClinicalCont")
image(ccont)
heat(ccont, cexCol = 0.5)
getTop(ccont, 2)
```

### Mutation Data
```{r }
cmaf <- getAllWeights(pl, "MAF")
image(cmaf)
heat(cmaf, cexCol = 0.5)
cmaf01 <- pickSignificant(cmaf, 0.01)
image(cmaf01)
heat(cmaf01, cexCol = 0.5)
getTop(cmaf01, 3)
```

### Methylation Data
```{r }
meth <- getAllWeights(pl, "Meth450")
image(meth)
heat(meth, cexCol = 0.5)
meth01 <- pickSignificant(meth, 0.01)
image(meth01)
heat(meth01, cexCol = 0.5)
getTop(meth01, 3)
```

### Proteomics Data
```{r }
rppa <- getAllWeights(pl, "RPPA")
image(rppa)
heat(rppa, cexCol = 0.5)
rppa01 <- pickSignificant(rppa, 0.01)
image(rppa01)
heat(rppa01, cexCol = 0.5)
getTop(rppa, 3)
```


### mRNA-Sequencing Data
```{r }
mrna <- getAllWeights(pl, "mRNASeq")
image(mrna)
heat(mrna, cexCol = 0.5)
mrna01 <- pickSignificant(mrna, 0.01)
image(mrna01)
heat(mrna01, cexCol = 0.5)
getTop(mrna01, 7)
```


### miR-Sequencing Data
```{r }
mir <- getAllWeights(pl, "miRSeq")
image(mir)
heat(mir, cexCol = 0.5)
mir01 <- pickSignificant(mir, 0.01)
image(mir01)
heat(mir01, cexCol = 0.5)
getTop(mir01, 5)
```

## Conclusions

# Appendix: MOFA2

```{r mofa, eval=FALSE}
suppressWarnings( library(MOFA2) )
```


