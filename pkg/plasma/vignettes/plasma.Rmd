---
title: "plasma: Partial LeAst Squares for Multi-omics Analysis"
author: "Kevin R. Coombes"
data: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{plasma: Partial LeAst Squares for Multi-omics Analysis}
  %\VignetteKeywords{OOMPA,plasma,supervised analysis,partial least squares}
  %\VignetteDepends{plasma}
  %\VignettePackage{plasma}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r opts, echo=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=5)
options(width=96)
.format <- knitr::opts_knit$get("rmarkdown.pandoc.to")
.tag <- function(N, cap ) ifelse(.format == "html",
                                 paste("Figure", N, ":",  cap),
                                 cap)
```
# Introduction
Recent years have seen the development of numerous algorithms and computational packages for
the analysis of multi-omics data sets. At this point, one can find multiple review articles
summarizing progress in the field [Subramanian-2020; Graw-2021; Heo-2021; Picard-2021;
Reel-2021; Vlachavas-2021; Adossa-2021]. As with other applications of
machine learning, the kinds of problems addressed by these algorithms are divided into
two categories: unsupervised (e.g., clustering or class discovery) or supervised
(including class comparison and class prediction). Advances in the area of unsupervised
learning have been broader and deeper than advances on supervised learning [CITE].

One of the most effective unsupervised methods is Multi-Omic Factor Analysis (MOFA)
[Argelaguet-2018; Argelaguet-2020]. A key property of MOFA is that it does not require
all omics assays to have been performed on all samples under study. In particular, it can
effectively discover class structure across omics data sets even when data for many
patients have only been acquired on a subset of the omics technologies. As of this
writing, we do not know of any supervised multi-omics method that can effectively learn
to predict outcomes when samples have only been assayed on a subset of the omics data sets.

MOFA starts with a standard method -- Latent Factor Analysis -- that is known to work 
well on single omics data set. It then fits a coherent model that identifies latent factors
that are common to, and able to explain the data well in, all the omics data sets under
study. Our investigation (unpublished) of the factors found by MOFA suggests that it is
approximately equivalent to a two-step process:

1. Use principal components analysis to identify initial latent factors in each individual
   omics data set.
2. For each pair of omics data sets, use overlapping samples to train and extend models of
   each factor to the union of assayed samples.

That interpretation of MOFA suggests that an analogous procedure might work for supervised
analyses as well. In this article, we describe a two-step algorithm, which we call "_plasma_",
to find models that can predict time-to-event outcomes on samples from multi-omics data sets
even in the presence of incomplete data. We use partial least squares (PLS) for both steps,
using Cox regression to learn the single omics models and linear regression to learn how to
extend models from one omics data set to another. To illustrate the method, we use a subset
of the esophageal cancer (ESCA) data set from The Cancer Genome Atlas (TCGA).


# Methods
Our computational method is implemented and the data are available in the `plasma` package.
```{r pkgs}
suppressWarnings( library(plasma) )
packageVersion("plasma")
```

## Data
We downloaded the entire esophageal cancer Level 3 data set from the TCGA on 6 August 2018. We
filtered the data sets so that only the most variable, and presumably the most informative,
features were retained. Here, we load this sample data set.
```{r data}
loadESCAdata()
sapply(assemble, dim)
```

1. From TCGA, we obtained 162 columns of clinical, demographic, and laboratory data on 185
   patients. We removed any columns that always contained the same value. We also removed
   any columns whose values were missing in more than 25% of the patients. We converted
   categorical variables into sets of binary variables using one-hot-encoding. We then
   separated the clinical data into three parts:
    1. Outcome (overall survival)
    2. Binary covariates (53 columns)
    3. Continuous covariates (6 columns)
1. Exome sequencing data for 184 patients with esophageal cancer was obtained as mutation allele
   format (MAF) files. We removed any gene that was mutated in fewer than 3% of the samples. The
   resulting data set contained 566 mutated genes.
2. Methylation data for 185 ESCA patients was obtained as beta values computed by the TCGA from
   Illumina Methylation 450K microarrays. We removed any CpG site for which the standard deviation
   of the beta values was less than 0.3. The resulting data set contained 1,454 highly variable
   CpG's.
3. Already normalized sequencing data on 2,566 microRNAs (miRs) was obtained for 185 patients.
   We removed any miR for which the standard deviation of normalized expression was less
   than 0.05, which left 926 miRs in the final data set.
4. Already normalized sequencing data on 20,531 mRNAs was obtained in 184 patients. We removed
   any mRNA whose mean normalized expression was less than 6 or whose standard deviation was less
   than 1.2. The final data set included 2,520 mRNAs.
5. Normalized expression data from reverse phase protein arrays (RPPA) was obtained from
   antibodies targeting 192 proteins in 126 patients. All data were retained for further analysis.

Finally, in order to be able to illustrate the ability of the plasma algorithm to work in
the presence of missing data, we randomly selected 10% of the patients to remove from
the miRSeq data set (leaving 166 patients) and 15% of the patients to remove from the
mRNASeq data set (leaving 157 patients). 


Here is a summary of the outcome data.
```{r outcome}
summary(Outcome)
```

## Imputation
We recommend imputing small amounts of missing data in te input data sets. The underlying issue
is that the PLS models we use for individual omics data sets will not be able to make predictions
on a sample if even one data point is missing. As a result, if sample is missing at least one
data point in every omics data set, then it will be impossible to use that sample at all.

For a range of available methods and R packages, consult the
[CRAN Task View on Missing Data](https://CRAN.R-project.org/view=MissingData).
We also recommend the [R-miss-tastic web site on missing data](https://rmisstastic.netlify.app/).
Their simulations suggest that, for purposes of producing predictive models from omics data,
the imputation method is not particularly important. Because of the latter finding, we have only
implemented two simple imputation methods in the `plasma` package:

1. `meanModeImputer` will replace any missing data by the mean value of the observed data if
   there are more than five distinct values; otherwise, it will replace missing data by the mode.
   This approach works relatively well for both continuous data and for binary or small categorical
   data.
2. `samplingImputer` replaces missing values by sampling randomly from the observed data distribution.

```{r impute}
set.seed(54321)
imputed <- lapply(assemble, samplingImputer)
```

## Computational Approach
The `plasma` algorithm is based on Partial Least Squares (PLS), which has been shown to be
an effective method for finding components that can predict clinically interesting outcomes
[Bastien-2015]. The workflow of the plasma algorithm is illustrated in **Figure 1** in the
case of three omics data sets. First, for each of the omics data sets, we apply the PLS Cox
regression algorithm (`plsRcox` Version `r packageVersion("plsRcox")` [Bertand-2021]) to the
time-to-event outcome data to learn three separate predictive models (indicated in red, green,
and blue, respectively). Each of these models may be incomplete, since they are not defined
for patients who have not been assayed (shown in white) using that particular omics technology.
Second, for each pair of omics data sets, we apply the PLS linear regression algorithm
(`pls` Version `r packageVersion("pls")` [Liland-2021]) to learn how to predict the coefficients of
the Cox regression components from one data set using features from the other data set. This step extends (shown in pastel red, green, and blue, resp.) each of the original models,
in different ways, from the intersection of samples assayed on both data sets to their union.
Third, we average all of the different extended models (ignoring missing data) to get a single
coherent model of component coefficients across all omics data sets. Assuming that this process
has been applied to learn the model from a training data set, we can evaluate the final Cox
regression model on both the training set and a test set of patient samples.

```{r fig01, out.width = "100%", fig.cap = .tag(1, "Workflow schematic for plasma algorithm with three omics data sets.")}
SF <- system.file("Figure/methods.png", package = "plasma")
knitr::include_graphics(SF)
rm(SF)
```

### Terminology
Because of the layered nature of the plasma algorithm, we intend to use the following terminology
to help clarify the later discussions.

1. The input data contains a list of _omics data sets_.
2. Each omics data set contains measurements of multiple _features_.
3. The first step in the algorithm uses PLS Cox regression to find a set of _components_.
   Each component is a linear combination of features. The components are used as predictors
   in a Cox proportional hazards model, which predicts the log hazard ratio as a linear
   combination of components.
4. The second step in the algorithm creates a secondary layer of components. We do not give
   these components a separate name. They are not an item of particular focus; we view them
   as a way to extend the first level components to more samples by "re-interpreting" them
   in other omics data sets.

## Preparing the Data
To be consistent with the `MOFA2` R package, all of the data sets are arranged so that patient
samples are columns and assay features are rows. Our first task is to pad each data set with
appropriate `NA`'s to ensure that each set includes the same patient samples in the same order,
where that order matches the outcome data frame.
```{r prep}
MO <- prepareMultiOmics(imputed, Outcome)
summary(MO)
```

We see that the number of patients in each data set is now equal to the number of patients
with clinical outcome data.


## Split Into Training and Test
As indicated above, we want to separate the data set into training and test samples. We will
use 60% for training and 40% for testing.
```{r split}
set.seed(54321)
#set.seed(34672)
splitVec <- rbinom(nrow(Outcome), 1, 0.6)
```

**Figure 2** presents a graphical overview of the number of samples (`N`) and the number of
features (`D`) in each omics component of the training and test sets.

```{r fig02, fig.cap = .tag(2, "Overview of training and test data."), fig.width=9, fig.height=8}
trainD <- MO[, splitVec == 1]
summary(trainD)
testD <- MO[, splitVec == 0]
summary(testD)
opar <- par(mai = c(1.02, 1.32, 0.82, 0.22), mfrow = c(1,2))
plot(trainD, main = "Train")
plot(testD, main = "Test")
par(opar)
```

# Results

## Individual PLS Cox Regression Models
The first step of the `plasma` algorithm is to fit PLS Cox models on each omics data set using
the function `fitCoxModels`. The returned object of class `MultiplePLSCoxModels` contains a list
of `SingleModel` objects, one for each assay, and within each there are three regression models:

* The `plsRcoxmodel` contains the coefficients of the components learned by PLS Cox regression.
  The number of components is determined automatically as a function of the logarithm of the
  number of features in the omics data set. The output of this model is a continuous prediction
  of "risk" for the time-to-event outcome of interest.
* Two separate models are constructed using the prediction of risk on the training data.
    + The `riskModel` is a `coxph` model using continuous predicted risk as a single predictor.
    + The `splitModel` is a `coxph` model using a binary split of the risk (at the median) as
      the predictor.

```{r fig03, fig.width = 8, fig.height = 12, fig.cap = .tag(3, "Kaplan-Meier plots of overall survival on the training set from separate PLS Cox omics models")}
suppressWarnings( firstPass <- fitCoxModels(trainD, timevar = "Days",
                          eventvar = "vital_status", eventvalue = "dead") )
summary(firstPass)
if (!interactive()) {
  plot(firstPass, legloc = "bottomleft") # margins too small inside RStudio window
}
```

On the training set, each of the seven contributing omics data sets is able to find a PLS
model that can successfully separate high risk from low risk patients (**Figure 3**).

## Extend Model Components Across Omics Data Sets
The second step of the algorithm is to extend the individual omics-based models across other omics
data sets. This step is performed using the `plasma` function, which takes in the previously
created objects of class `multiOmics` and `MultiplePLSCoxModels`. The function operates
iteratively, so in our case there are seven different sets of predictions of the PLS
components. These different predictions are averaged and saved internally as a data frame
called `meanPredictions`. The structure of models created and stored in the `plasma` object is
the same as for the separate, individual, omics models. **Figure 4** shows the Kaplan-Meier plot
using the predicted risk, split at the median value, on the training data set.

```{r fig04, fig.cap = .tag(4, "Kaplan-Meier plot of overall survival on the training set using the unified `plasma` Cox model.")}
pl <- plasma(MO, firstPass)
plot(pl, legloc = "topright", main = "Training Data", xlab = "Time (Days)")
```

## Independent Test Set
Now we want to see how well the final composite model generalizes to our test set. **Figure 5**
uses the predicted risk, split at the median of the training data, to construct a Kaplan-Meier
plot on the test data. The model yields a statistically significant (p = 0.0063) separation of
outcomes between the high and low risk patients.

```{r fig05, fig.cap = .tag(5, "Kaplan-Meier plot of overall survival on the test set.")}
testpred <- predict(pl, testD)
plot(testpred, main="Testing Data", xlab = "Time (Days)")
```

## Interpretation
At this point, our model appears to be a fairly complex black box. We have constructed a matrix
of components, based on linear combinations of actual features in different omics data sets.
These components can then be combined in yet another linear model that predicts the time-to-event
outcome through Cox regression. In this section, we want to explore how the individual features
from different omics data sets contribute to different model components.

Our first act toward opening the black box is to realize that not all of the components discovered
from the individual omics data sets survived into the final composite model. Some components were
eliminated because they appeared to be nearly linearly related to components found in other omics
data sets. So, we can examine the final composite model more closely.
```{r fullModel}
pl@fullModel
temp <- terms(pl@fullModel)
mainterms <- attr(temp, "term.labels")
rm(temp)
mainterms
```
We see that at least one component discovered from each of the five "true" omics data sets
survived in the final model. However, neither the binary clinical nor continuous clinical data sets
contributed independent components. 

Our interest now turns to understanding how the features from individual omics data
sets contribute to the components that are used in the final model. As mentioned 
earlier, these contributions are mediated through two levels of linear regression
models when extending a model from data set A to data set B. A linear combination
of features from set B is used to define the secondary level of components; then
a linear combination of these components is used to predict the components of the
single Cox model built that had been from set A. These weights can be combined and
extracted using the `getAllWeights` function, and can then be explored.

### Clinical Binary Data
We use the binary clinical data set to illustrate our methods for interpreting the components.
```{r fig06, fig.cap = .tag(6, "Unscaled heatmap of the contributions of binary clinical features to all components."), fig.height = 7}
if (requireNamespace("oompaBase")) {
  HG <- oompaBase::blueyellow(64)
} else {
  HG <- heat.colors(64)
}
cbin <- getAllWeights(pl, "ClinicalBin")
heat(cbin, cexCol = 0.9, cexRow = 0.5, col = HG)
```

**Figure 6** shows the raw weights for each clinical binary feature in all of the original
omics components. **Figure 7** only includes the omics components that were retained in the
final composite model. Structurally, these two figures look similar. There is a central set
of components where all of the weights look weak, and a central set of features that appear
to have weak contributions to all components.

```{r fig07, fig.cap = .tag(7, "Unscaled heatmap of the contributions of binary clinical features to important components."), fig.height = 7}
heat(cbin[, mainterms], cexCol = 0.9, cexRow = 0.5, col = HG)
```

We hypothesize that some components intrinsically have a wider spread of weights, and that
it might be more important to scale the components consistently to look at the relative
contributions (**Figure 8**). By standardizing the weights component by component, we see
a better balance of contributions per component. However, we can still identify a set of
features that seem to make no contributions to any of the components. We can filter the
features by only retaining those that make a large contribution to at least one omics
component (**Figure 9**). 

```{r fig08, fig.cap = .tag(8, "Scaled heatmap of the contributions of binary clinical features to important components."), fig.height = 7}
dbin <- cbin[, mainterms]
dbin@contrib <- scale(dbin@contrib)
heat(dbin, cexCol = 0.9, cexRow = 0.5, col = HG)
```


```{r fig09, fig.cap = .tag(9, "Scaled heatmap of the contributions of filtered binary clinical features to important components."), fig.height = 7}
shrink <- function(dset, N) {
  dset@contrib <- scale(dset@contrib)
  feat <- unique(unlist(as.list(getTop(dset, N))))
  dset@contrib <- dset@contrib[feat, mainterms]
  dset
}
xbin <- shrink(cbin, 4)
heat(xbin, cexCol = 0.9, cexRow = 0.9, col = HG)
```
In **Figure 9**, we can identify strong contrasts between several pairs of variables. For example,
one set of components is enriched with white, never smokers, who still have evidence of tumors, at
stage T3 and grade 3 in the lower third of the esophagus (ICD-10 code C15.5), while another group
is enriched for Asian, current smokers, who are tumor-free, with stage N0, T2 tumors from the
lower third of the esophagus (ICD-10 code C15.4).

### Clinical Continuous Data
```{r fig10, fig.cap = .tag(10, "Scaled heatmap of the contributions of filtered continuous clinical features to important components")}
ccont <- getAllWeights(pl, "ClinicalCont")
xcont <- shrink(ccont, 2)
heat(xcont, cexCol = 0.8, cexRow = 1.2, col = HG)
```

The most important continuous clinical feature is the patient's weight, which is positively
correlated (yellow) with four components and negatively correlated (blue) with six others.

### Mutation Data
```{r fig11, fig.cap = .tag(11, "Scaled heatmap of the contributions of filtered mutation features to important components"), fig.height = 7}
cmaf <- getAllWeights(pl, "MAF")
xmaf <- shrink(cmaf, 4)
heat(xmaf, cexCol = 0.9, cexRow = 0.9, col = HG)
```

### Methylation Data
```{r fig12, fig.cap = .tag(12, "Scaled heatmap of the contributions of filtered methylation features to important components"), fig.height = 7}
meth <- getAllWeights(pl, "Meth450")
xmeth <- shrink(meth, 4)
heat(xmeth, cexCol = 0.9, cexRow = 0.9, col = HG)
```

### Proteomics Data
```{r fig13, fig.cap = .tag(13, "Scaled heatmap of the contributions of filtered RPPA features to important components"), fig.height = 7}
rppa <- getAllWeights(pl, "RPPA")
xrppa <- shrink(rppa, 5)
tmp <- rownames(xrppa@contrib)
rownames(xrppa@contrib) <- sapply(strsplit(tmp, "\\."), function(x) paste(x[-1], collapse = "."))
hc <- heat(xrppa, cexCol = 0.9, cexRow = 0.9, col = HG, keep.dendro = TRUE)
```


### mRNA-Sequencing Data
```{r fig14, fig.cap = .tag(14, "Scaled heatmap of the contributions of filtered mRNA features to important components"), fig.height = 7}
mrna <- getAllWeights(pl, "mRNASeq")
xmrna <- shrink(mrna, 7)
tmp <- rownames(xmrna@contrib)
rownames(xmrna@contrib) <- sapply(strsplit(tmp, "\\."), function(x) x[1])
heat(xmrna, cexCol = 0.9, cexRow = 0.6, col = HG)
```


### miR-Sequencing Data
```{r fig15, fig.cap = .tag(15, "Scaled heatmap of the contributions of filtered miR features to important components"), fig.height = 7}
mir <- getAllWeights(pl, "miRSeq")
xmir <- shrink(mir, 5)
tmp <- strsplit(rownames(xmir@contrib), "\\.")
nc <- sapply(tmp, length)
rownames(xmir@contrib) <- sapply(1:length(tmp), function(dex) 
  paste(tmp[[dex]][1:(nc[dex]-1)], collapse = "."))
heat(xmir, cexCol = 0.9, cexRow = 0.9, col = HG)
```

## Uniting the Contributors
Here we put a record of all the contributions into a single data frame, with an accompanying
factor tracking the source data set.
```{r contra}
contra <- rbind(cbin@contrib, ccont@contrib, cmaf@contrib, meth@contrib,
             mir@contrib, mrna@contrib, rppa@contrib)
featsize <- sapply(list(cbin@contrib, ccont@contrib, cmaf@contrib, meth@contrib,
                        mir@contrib, mrna@contrib, rppa@contrib), nrow)
datasrc <- factor(rep(c("cbin", "ccont", "maf", "meth", "mir", "mrna", "rppa"), times = featsize))
```

**Figure 16** displays the mean, standard deviation (SD), median and median absolute deviation (MAD)
of the weight-contributions for each data set in each component. 
```{r fig16, fig.cap = .tag(16, "Summary statustics of weights by component and dataset."), fig.width = 10, fig.height = 10}
mu <- aggregate(contra, list(datasrc), mean)
rownames(mu) <- mu[, 1]
mu$Group.1 <- NULL
mu <- as.matrix(mu)
sigma <- aggregate(contra, list(datasrc), sd)
rownames(sigma) <- sigma[, 1]
sigma$Group.1 <- NULL
sigma <- as.matrix(sigma)

med <- aggregate(contra, list(datasrc), median)
rownames(med) <- med[, 1]
med$Group.1 <- NULL
med <- as.matrix(med)
mmad <- aggregate(contra, list(datasrc), mad)
rownames(mmad) <- mmad[, 1]
mmad$Group.1 <- NULL
mmad <- as.matrix(mmad)
mx <- max(abs(mu))
sx <- max(sigma)
dx <- max(abs(med))
ax <- max(mmad)
library(oompaBase)
opar <- par(mfrow = c(2,2))
image(1:24, 1:7, t(mu), xlab = "Component", ylab = "Dataset", main = "Mean",
      zlim = c(-mx, mx), col = redgreen(64))
image(1:24, 1:7, t(sigma), xlab = "Component", ylab = "Dataset", main = "SD",
      zlim = c(0, sx), col = redscale(64))
image(1:24, 1:7, t(med), xlab = "Component", ylab = "Dataset", main = "Median",
      zlim =c(-dx, dx), col = redgreen(64))
image(1:24, 1:7, t(mmad), xlab = "Component", ylab = "Dataset", main = "Mad",
      zlim = c(0, ax), col = redscale(64))
par(opar)
rm(opar)
```

### Raw Weights
In **Figure 17**, we create beanplots showing the distributions of weights arising from each
data set in each component. Some data sts have very different contribution patterns than others.
For example, the "Clinical Binary" data set appears to have significant outliers making large
contributions in almost every component, THA MAF and RPPA data sets also frequently (but not
always) include such outliers.
```{r fig17, fig.cap = .tag(17, "Distributions of weights by data set and component."), fig.width = 12, fig.height = 18}
library(beanplot)
library(Polychrome)
data(alphabet)
CB <- cbin@contrib
opar <- par(mfrow = c(6, 4), mai = c(0.2,0.2, 0.5, 0.2))
for (i in 1:24) {
  beanplot(contra[, i] ~ datasrc, what = c(1,1,1,0), col = as.list(alphabet[1:7]),
           main = paste("Component ", i, " (", colnames(CB)[i], ")", sep = ""))
}
par(opar)
rm(opar)
```

**Figure 18** lumps the weights from all data sets together to view the distributions by component.
Most of these histograms are centered near 0 and are roughly symmetric. Exceptions include component
eleven, where there is a bias toward negative weights. The scale of the outliers also varies
dramatically, with most component weights having a range much less than 1, but component eighteen
having a range between +4 and -4.
```{r fig18, fig.cap = .tag(18, "Histogram of weights by component."), fig.width = 12, fig.height = 18}
opar <- par(mfrow = c(6, 4), mai = c(0.4,0.4, 0.5, 0.2))
for (i in 1:24) {
  hist(contra[,i], breaks = 77, main = paste("Component", i))
}
par(opar)
rm(opar)
```

### Standardized Weights

In **Figure 19**, we have standardized the weights in each data set and component, and recreate the
corresponding beanplot distributions. The standardization has moved the outliers away from the three
previous data sets (clinical binary, MAF, and RPPA) primarily to the miRs, thought with more dispersed contributions as well.
```{r fig19, fig.cap = .tag(19, "Distributions of standardized weights by data set and component."), fig.width = 12, fig.height = 18}
M <- apply(mu, 2, function(X) rep(X, times = featsize))
S <- apply(sigma, 2, function(X) rep(X, times = featsize))
brute <- (contra - M)/S
opar <- par(mfrow = c(6, 4), mai = c(0.2,0.2, 0.5, 0.2))
for (i in 1:24) {
  beanplot(brute[, i] ~ datasrc, what = c(1,1,1,0), col = as.list(alphabet[1:7]),
           main = paste("Std Wts, Component", i))
}
par(opar)
rm(opar)
```

We also include plots of the histograms of distributions by component (**Figure 20**). None of
these really looks normal; they almost have some odd shape and signs of skewness.
```{r fig20, fig.cap = .tag(20, "Histogram of standardized weights by component."), fig.width = 12, fig.height = 18}
opar <- par(mfrow = c(6, 4), mai = c(0.2,0.2, 0.5, 0.2))
for (i in 1:24) {
  hist(brute[,i], breaks = 77, main = paste("Component", i))
}
par(opar)
rm(opar)
```

### Robust Standardized Weights
Since th standardization in the previous section could have been affected by numerous outliers,
we decide to replace the mean and standard deviation by their robust versions, the median and
the MAD (median absolute deviation). In **Figure 21**, we show the corresponding beanplot
distributions. here all of th plots of the clinical continuos data look weird, but that may
be because there are only six features in that data set. The miRs also end up with many of the
largest contributions, for reasons that are unclear.
```{r fig21, fig.cap = .tag(21, "Distributions of robust standardized weights by data set and component."), fig.width = 12, fig.height = 18}
M <- apply(med, 2, function(X) rep(X, times = featsize))
S <- apply(mmad, 2, function(X) rep(X, times = featsize))
robust <- (contra - M)/S
opar <- par(mfrow = c(6, 4), mai = c(0.2,0.2, 0.5, 0.2))
for (i in 1:24) {
  beanplot(robust[, i] ~ datasrc, what = c(1,1,1,0), col = as.list(alphabet[1:7]),
           main = paste("Robust Std Wts, Component", i))
}
par(opar)
rm(opar)
```

One positive outcome from robust standardization is that the combined histograms look more sensible.
In addition to being centered at zero, they have a much miore symmetric look than the ones we got
using th usual mean and SD for standardization.
```{r fig22, fig.cap = .tag(22, "Histogram of robust standardized weights by component."), fig.width = 12, fig.height = 18}
opar <- par(mfrow = c(6, 4), mai = c(0.2,0.2, 0.5, 0.2))
for (i in 1:24) {
  hist(robust[,i], breaks = 77, main = paste("Component", i))
}
par(opar)
rm(opar)
```

### Top Twenty Lists
Next, we want to see how many items in the "top twenty" lists come from each data set. The results
are shown in **Figure 23**. Using the raw weights, the vast majority of contributions come from
the clinical binary data, with secondary contributions from the MAF and RPPA data sets (as we expected
from the above distribution plots). After (the usual) standardization, most of the contributions arise
from miRs, but the methylation, mRNA and, to a lesser extent, the MAF and RPPA data sets also are present.
After robust standardization, however, almost everything in the top 20 comes from the miRs.
```{r fig23, fig.cap = .tag(23, "Number of contributers to top twenty lists."), fig.width=12, fig.height=6}
top20 <- apply(contra, 2, function(X) {
  A <- abs(X)
  S <- rev(sort(A))
  which(A > S[21])
})
top20types <- apply(top20, 2, function(X) {
  table(datasrc[X])
})

chop20 <- apply(brute, 2, function(X) {
  A <- abs(X)
  S <- rev(sort(A))
  which(A > S[21])
})
chop20types <- apply(chop20, 2, function(X) {
  table(datasrc[X])
})

rop20 <- apply(robust, 2, function(X) {
  A <- abs(X)
  S <- rev(sort(A))
  which(A > S[21])
})
rop20types <- apply(rop20, 2, function(X) {
  table(datasrc[X])
})


opar <- par(mfrow = c(1, 3))
image(1:7, 1:24, top20types, main = "Raw Weights", ylab = "Components", xlab = "Data Sets")
mtext(levels(datasrc),side = 3, at = 1:7, line = 0)
image(1:7, 1:24, chop20types, main = "Standardized Weights", ylab = "Components", xlab = "Data Sets")
mtext(levels(datasrc),side = 3, at = 1:7, line = 0)
image(1:7, 1:24, rop20types, main = "Robust Weights", ylab = "Components", xlab = "Data Sets")
mtext(levels(datasrc),side = 3, at = 1:7, line = 0)
par(opar)
rm(opar)
```

# Conclusions
We have identified a method analogous to that of `MOFA` that allows us
to combine different omics data without the need for prior imputation
of missing values. A major difference is that while `MOFA` model
learns "factors" that are composites of the variables in an
unsupervised fashion, the `plasma` model learns "components" that are
composites of the variables in an supervised fashion, using the
outcomes "event" and "time-to-event" as response variables.

Although the factors from `MOFA` are defined such that the efirst
factor, Factor 1, accounts for the greatest variance in the model, the
factors' may or may not be significantly associated with the outcome,
and a post-hoc survival analysis would need to be done to assess
this. It may be the case that some factors, although they are
significantly associated with outcome, account for very small variance
in the final `MOFA` model, which hinders interpretability. This was
the case with the TCGA-ESCA dataset, in which, when 10 factors were
learned from the `MOFA` model, only Factor 10 was significantly
associated with survival, while accounting for [number] variance in
the model [CITE SUPPLEMENTARY RESULTS?]. On the other hand, the
components for `plasma` are created in a way that maximizes the
covariance in the predictors and the response, and therefore these
components will be automatically associated to some degree with the
outcome. This could be advantageous in that dissecting the weights
associated with the components would yield a list of variables from
different omics datasets that contribute the most to defining the
outcome, and any additional analyses could be refined by looking at
these high-weighted variables most closely.

# Appendix: MOFA2

```{r mofa, eval=FALSE}
suppressWarnings( library(MOFA2) )
```
