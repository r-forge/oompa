---
title: "Compare weighted to unweighted averages"
author: "Kyoko Yamaguchi"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: yeti
    highlight: kate
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This document attemts to 1) calculate some reasonable vector of weights for multiplication during the "extention" portion of the plasma function and 2) compare the root mean squared error (RMSE) between the truth and predictions using the unweighted averages and the weighted averages to see if the weights actually make a difference.


# This is a document to compare weighted to unweighted averages

```{r packages}
library(dplyr)
library(pls)
library(plsRcox)
library(survival)
library(plasma)
```

Load data and libraries

```{r escadata}
# load("C:/Users/Owner/Desktop/svn_oompa_dev/prePlasma/TCGA-ESCA-full.RData")
plasma::loadESCAdata()
```

```{r peek}
suspects <- c("A4OM", "A49V", "A8NI")
Outcome[suspects,] # nothing special
sapply(assemble, function(X) (suspects %in% colnames(X)))
sapply(assemble, function(X) {
  S <- suspects[suspects %in% colnames(X)]
  apply(X[, S, drop = FALSE], 2, summary)
})
ls()
```
We have minor missing data in the ClinicalBin data set for two suspect samples (A4OM, A49V).
We also have completely missing data in some of the omics data sets. Other than that, things
look fine.

# Proof of concept for one iteration only
## Dataset shrinking
What if we shrink to some percentage of its original size?
Output the names of the datasets that are going to be shrunken:
```{r shrink}
set.seed(123)
namesub<- c("MAF", "Meth450", "miRSeq", "mRNASeq")
percentage <- 0.90

nameofdataset <- sample(x=namesub, size=2)
nameofdataset[1]
first<-assemble[[ nameofdataset[1] ]]
first <- first[, sample(ncol(first), percentage*ncol(first))]
dim(first)

nameofdataset[2]
second<-assemble[[ nameofdataset[2] ]]
second <- second[, sample(ncol(second), percentage*ncol(second))]
dim(second)

# assemble the datasets
assemble_shrink <- assemble
assemble_shrink[[ which(names(assemble_shrink) == nameofdataset[1]) ]] <- first
assemble_shrink[[ which(names(assemble_shrink) == nameofdataset[2]) ]] <- second

# subset on only the continuous data?
assemble_shrink <- assemble_shrink[ which(names(assemble) %in% namesub) ]
```

```{r peek.shrink}
sapply(assemble_shrink, function(X) (suspects %in% colnames(X)))
sapply(assemble_shrink, function(X) {
  S <- suspects[suspects %in% colnames(X)]
  apply(X[, S, drop = FALSE], 2, summary)
})
```
Now none of the three "suspects" are present in the shrunken miRSeq or mRNASeq data sets.
But we also see (here as above) that there are one or two missing data points within both
the MAF and Meth450 data sets as well.
```{r checkNA}
maf <- assemble$MAF[,suspects]
pick <- apply(maf, 1, function(x) any(is.na(x)))
maf[pick,]

meth <- assemble$Meth450[,suspects]
pick <- apply(meth, 1, function(x) any(is.na(x)))
meth[pick,]
```


```{r truth}
assemble_truth <- assemble[ which(names(assemble) %in% namesub) ]
```


assemble_truth contains the original unmodified data. The model arising from assemble represents our "ground truth" model.

```{r truthdim}
lapply(assemble_truth, dim)
```

assemble_shrink contains the shrunken data. The model arising from reassemble represents our "estimated" model.

```{r shrindim}
lapply(assemble_shrink, dim)
```

## Run the analysis with these selected datasets and the unweighted averages
### Make the true model (with the full data)

```{r MOtruth}
MO_truth <- prepareMultiOmics(assemble_truth, Outcome)
suppressWarnings( firstPass_truth <- fitCoxModels(MO_truth, timevar = "Days",
                          eventvar = "vital_status", eventvalue = "dead") )
plot(firstPass_truth)
```

```{r peektruth}
lapply(namesub, function(ds) {
  A <- firstPass_truth@models[[ds]]
  A@Xout[suspects,]
})
```
When we look into the single-omic models, we see the expected results. Specifically, 
we get reasonable values when the sample is in the omics data set, and get NA's otherwise.
**WAIT!** Shouldn't it be the case that all the names are present in all the data sets?
```{r closerlook}
sapply(namesub, function(ds) {
  A <- firstPass_truth@models[[ds]]
  dim(A@Xout)
})
```
Never mind; these do not get automatically expanded to the full sample set. So, everything
is as it should be so far.

```{r pltruth}
pl_truth <- plasma(MO_truth, firstPass_truth)
# plot(pl_truth, legloc = "topright", main = "True Data")
```

```{r followuptruth}
mp <- pl_truth@meanPredictions
mp[suspects,]
```
One of the "suspects" produces NaN's across the board. Let's see if we can figure out
where that comes from.
```{r whyna}
modlist <- pl_truth@compModels
for (N in names(modlist)) {
  print(N)
  X <- modlist[[N]]
  Y <- X$allPred
  S <- suspects[suspects %in% rownames(Y)]
  print(Y[S, , drop = FALSE], 2)
}
```
Well, it seems that we have no data for suspect `A8NI`. That makes it hard to pool
the prediction data. But why do we get NA's from the MAF and Meth450 data sets, even though
we know most of the data is available there?
```{r mafbad}
A <- modlist$MAF$allPred
awful <- apply(A, 1, function(x) all(is.na(x)))

pick <- apply(assemble$MAF, 2, function(x) any(is.na(x)))
all(names(pick) == names(awful))
summary(awful)
awful <- awful[names(pick)]
table(awful, pick)
```


### Make the estimate model (i.e. with the shrunken data)

```{r moshrink}
MO_shrink <- prepareMultiOmics(assemble_shrink, Outcome)

suppressWarnings( firstPass_shrink <- fitCoxModels(MO_shrink, timevar = "Days",
                          eventvar = "vital_status", eventvalue = "dead") )
plot(firstPass_shrink)
```

```{r plshrink}
pl_shrink <- plasma(MO_shrink, firstPass_shrink)
# plot(pl_shrink, legloc = "topright", main = "True Data")
```

Upon looking at the meanPredictions table in pl_shrink, there are a few patients that have rows that are completely populated with NaN. Why is this the case?

```{r}
plshrinkmeanpred<- pl_shrink@meanPredictions

brrr<-is.na(rowSums(plshrinkmeanpred))

table(brrr)

plshrinkmeanpred[which(brrr),]
```

```{r}
# reference
is.na(NaN)
is.na(NaN+NaN)

# reference, FALSE = 0, TRUE = 1
FALSE + FALSE
TRUE + TRUE
FALSE + TRUE
```

```{r}
# do the patients in meanPredictions that are NaN follow a pattern?

hmm<- MO_shrink@data

listoflogicals<-list()

for (i in 1:length(hmm)){
   listoflogicals[[i]]<- apply(hmm[[i]], 2,function(x) sum(is.na(x))==length(x))
  # print(a)
   
}

thesum<- listoflogicals[[1]] + listoflogicals[[2]] + listoflogicals[[3]] + listoflogicals[[4]] 

sort(thesum, decreasing = TRUE)
```

```{r}
ptsNaN<- rownames(plshrinkmeanpred[which(brrr),])

thesum[names(thesum) %in% ptsNaN]
```

How about in the full model?


```{r}
which(is.na(rowSums(pl_truth@meanPredictions)))

pl_truth@meanPredictions[which(is.na(rowSums(pl_truth@meanPredictions))),]
```


Additional comments:
The "fullmodel" in the pl_truth object only contains n=184 instead of the full 185? A8NI is missing from the pl@fullModel["y"]

### Calculate RMSE between truth and predictions
We need to compare 1) pl_truth vs pl_shrink and 2) pl_truth vs pl_weighted_shrink to see which begets the lower RMSE value.
We may need to subset on the patients that contain real values, ignoring the NaNs.

First, compare pl_truth vs pl_shrink:

Not sure what to calculate RMSE on, so I could do:
1) The entire meanPredictions matrix (pl_truth@meanPredictions)
2) Just the vector of predicted risks (pl_truth@riskDF[["Risk"]])
etc...
